"""
Q19
Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней. Игроки ходят по очереди, первый
ход делает Петя. За один ход игрок может добавить в одну из куч (по своему выбору) один камень или увеличить количество
камней в куче в два раза. Для того чтобы делать ходы, у каждого игрока есть неограниченное количество камней.
Игра завершается в тот момент, когда суммарное количество камней в кучах снатовится не менее 259. Победителем считается
игрок, сделавший последний ход, т.е. первым получивший такую позицию, при которой в кучах будет 259 или больше камней.
В начальный момент в первой куче было 17 камней, во второй куче - S камней; 1 <= S <= 241. Будем говорить, что игрок
имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. Укажите минимальное значение S, когда
такая ситуация возможна.

Q20
Для игры, описанной в предыдущем задании, найдите два нименьших значения S, при которых у Пети есть выиграшная
стратегия, причём одновременно выполняются два условия:
- Петя не может выиграть за один ход.
- Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.

Q21
Для игры, описанной в задании 19, найдите мнимальное значение S, при котором одновременно выполняются два условия:
- у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
- у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
"""


def do1(go):
    return go + 1


def do2(go):
    return go * 2


def f19(x, y, p=1):
    if x + y >= wins and p == 3: return True
    if x + y < wins and p == 3: return False

    return f19(do1(x), y, p + 1) or f19(do2(x), y, p + 1) or f19(x, do1(y), p + 1) or f19(x, do2(y), p + 1)


def f20(x, y, p=1):
    if x + y >= wins and p == 4: return True
    if x + y < wins and p == 4: return False
    if x + y >= wins: return False

    if p % 2 == 0:
        return f20(do1(x), y, p + 1) and f20(do2(x), y, p + 1) and f20(x, do1(y), p + 1) and f20(x, do2(y), p + 1)
    else:
        return f20(do1(x), y, p + 1) or f20(do2(x), y, p + 1) or f20(x, do1(y), p + 1) or f20(x, do2(y), p + 1)


def f21(x, y, p=1):
    if x + y >= wins and (p == 3 or p == 5): return True
    if x + y < wins and p == 5: return False
    if x + y >= wins: return False

    if p % 2 == 1:
        return f21(do1(x), y, p + 1) and f21(do2(x), y, p + 1) and f21(x, do1(y), p + 1) and f21(x, do2(y), p + 1)
    else:
        return f21(do1(x), y, p + 1) or f21(do2(x), y, p + 1) or f21(x, do1(y), p + 1) or f21(x, do2(y), p + 1)


def f21m(x, y, p=1):
    if x >= wins and p == 3: return True
    if x < wins and p == 3: return False
    if x >= wins: return False

    if p % 2 == 1:
        return f21m(do1(x), y, p + 1) and f21m(do2(x), y, p + 1) and f21m(x, do1(y), p + 1) and f21m(x, do2(y), p + 1)
    else:
        return f21m(do1(x), y, p + 1) or f21m(do2(x), y, p + 1) or f21m(x, do1(y), p + 1) or f21m(x, do2(y), p + 1)


# Условия
start = 1
hip1 = 17
wins = 259
stop = wins - hip1
# Q19
print('-' * 10 + 'Q19' + '-' * 10)
for s in range(start, stop):
    if f19(hip1, s):
        print(s)
        break

# Q20
print('-' * 10 + 'Q20' + '-' * 10)
for s in range(start, stop):
    if f20(hip1, s):
        print(s)

# Q21
print('-' * 10 + 'Q21' + '-' * 10)
for s in range(start, stop):
    if f21(hip1, s):
        print(s)

print()

for s in range(start, stop):
    if f21m(hip1, s):
        print(s)
